<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/assets/favicons/android-chrome-192x192.png" sizes=192x192>
  <link rel="icon" type="image/png" href="/assets/favicons/android-chrome-512x512.png" sizes=512x512>
  <link rel="apple-touch-icon" type="image/png" href="/assets/favicons/apple-touch-icon.png" sizes=x>
  <link rel="icon" type="image/png" href="/assets/favicons/favicon-16x16.png" sizes=16x16>
  <link rel="icon" type="image/png" href="/assets/favicons/favicon-32x32.png" sizes=32x32>
  <link rel="icon" type="image/x-icon" href="/assets/favicons/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Vertex Covers and Independent Sets in game level design - Marek Narozniak's Homepage</title>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/">
  <link rel="alternate" type="application/rss+xml" title="Marek Narozniak's Homepage" href="https://mareknarozniak.com/feed.xml">
  <link rel="stylesheet" href="/assets/katex/katex.css">
  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Vertex Covers and Independent Sets in game level design | Marek Narozniak’s Homepage</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Vertex Covers and Independent Sets in game level design" />
<meta name="author" content="Marek Narozniak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A tutorial on how to model game design problems with basic graph theory problems with a cool Pokémon example problem!" />
<meta property="og:description" content="A tutorial on how to model game design problems with basic graph theory problems with a cool Pokémon example problem!" />
<link rel="canonical" href="https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/" />
<meta property="og:url" content="https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/" />
<meta property="og:site_name" content="Marek Narozniak’s Homepage" />
<meta property="og:image" content="https://mareknarozniak.com/assets/figures/vc_mis_results.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-22T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="https://mareknarozniak.com/assets/figures/vc_mis_results.png" />
<meta property="twitter:title" content="Vertex Covers and Independent Sets in game level design" />
<meta name="twitter:site" content="@MarekNarozniak" />
<meta name="twitter:creator" content="@MarekNarozniak" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/"},"image":"https://mareknarozniak.com/assets/figures/vc_mis_results.png","url":"https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/","author":{"@type":"Person","name":"Marek Narozniak"},"headline":"Vertex Covers and Independent Sets in game level design","description":"A tutorial on how to model game design problems with basic graph theory problems with a cool Pokémon example problem!","datePublished":"2020-04-22T00:00:00+08:00","dateModified":"2020-04-22T00:00:00+08:00","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  
</head>

  <body>
    <div class="page-content">
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <span class="back">&larr; <a href="/">Index</a></span>
    <h1 class="post-title" itemprop="name headline">Vertex Covers and Independent Sets in game level design</h1>
    <p class="post-meta">
      <time datetime="2020-04-22T00:00:00+08:00" itemprop="datePublished">Apr 22, 2020</time>
      


      
       • tags:
      
      
      <span class="tags" itemprop="tags">
          
          
          
          
          
          
          <a href="https://mareknarozniak.com/tagged#computer-science">#Computer Science</a>
        <a href="https://mareknarozniak.com/tagged#graph-theory">#Graph Theory</a>
        <a href="https://mareknarozniak.com/tagged#optimization">#Optimization</a>
        <a href="https://mareknarozniak.com/tagged#problems">#Problems</a>
        <a href="https://mareknarozniak.com/tagged#pokémon">#Pokémon</a>
        <a href="https://mareknarozniak.com/tagged#python">#Python</a>
        <a href="https://mareknarozniak.com/tagged#game-design">#Game Design</a>
        </span>
      
    
    
    


      

    </p>
    

<style>
#share-buttons {display: inline-block; vertical-align: middle; }
#share-buttons:after {content: ""; display: block; clear: both;}
#share-buttons > div {
    position: relative;
    text-align: left;
    height: 36px;
    width: 32px;
    float: left;
    text-align: center;
}
#share-buttons > div > svg {height: 16px; fill: #d5d5d5; margin-top: 10px;}
#share-buttons > div:hover {cursor: pointer;}
#share-buttons > div.facebook:hover > svg {fill: #3B5998;}
#share-buttons > div.twitter:hover > svg {fill: #55ACEE;}
#share-buttons > div.linkedin:hover > svg {fill: #0077b5;}
#share-buttons > div.pinterest:hover > svg {fill: #CB2027;}
#share-buttons > div.gplus:hover > svg {fill: #dd4b39;}
#share-buttons > div.mail:hover > svg {fill: #7D7D7D;}
#share-buttons > div.instagram:hover > svg {fill: #C73B92;}
#share-buttons > div.facebook > svg {height: 18px; margin-top: 9px;}
#share-buttons > div.twitter > svg {height: 20px; margin-top: 8px;}
#share-buttons > div.linkedin > svg {height: 19px; margin-top: 7px;}
#share-buttons > div.pinterest > svg {height: 20px; margin-top: 9px;}
#share-buttons > div.gplus > svg {height: 17px; margin-top: 9px; position: relative; left: 1px;}
#share-buttons > div.mail > svg {height: 14px; margin-top: 11px;}
</style>

<span style="color: silver;">Share on: </span><div id="share-buttons">
    <div class="facebook" title="Share this on Facebook" onclick="window.open('http://www.facebook.com/share.php?u=https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759h-306v-759h-255v-296h255v-218q0-186 104-288.5t277-102.5q147 0 228 12z"/></svg></div>
    <div class="twitter" title="Share this on Twitter" onclick="window.open('https://twitter.com/intent/tweet?text=Vertex Covers and Independent Sets in game level design&url=https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"/></svg></div>
    <div class="linkedin" title="Share this on Linkedin" onclick="window.open('https://www.linkedin.com/shareArticle?mini=true&url=https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/&title=&summary=&source=');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M477 625v991h-330v-991h330zm21-306q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zm1166 729v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z"/></svg></div>
    <div class="pinterest" title="Share this on Pinterest" onclick="window.open('https://pinterest.com/pin/create/button/?url=&media=https://mareknarozniak.com/assets/figures/vc_mis_results.png&description=');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M256 597q0-108 37.5-203.5t103.5-166.5 152-123 185-78 202-26q158 0 294 66.5t221 193.5 85 287q0 96-19 188t-60 177-100 149.5-145 103-189 38.5q-68 0-135-32t-96-88q-10 39-28 112.5t-23.5 95-20.5 71-26 71-32 62.5-46 77.5-62 86.5l-14 5-9-10q-15-157-15-188 0-92 21.5-206.5t66.5-287.5 52-203q-32-65-32-169 0-83 52-156t132-73q61 0 95 40.5t34 102.5q0 66-44 191t-44 187q0 63 45 104.5t109 41.5q55 0 102-25t78.5-68 56-95 38-110.5 20-111 6.5-99.5q0-173-109.5-269.5t-285.5-96.5q-200 0-334 129.5t-134 328.5q0 44 12.5 85t27 65 27 45.5 12.5 30.5q0 28-15 73t-37 45q-2 0-17-3-51-15-90.5-56t-61-94.5-32.5-108-11-106.5z"/></svg></div>
    <div class="gplus" title="Share this on Google Plus" onclick="window.open('https://plus.google.com/share?url=https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/');"><svg viewBox="0 0 2304 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1437 913q0 208-87 370.5t-248 254-369 91.5q-149 0-285-58t-234-156-156-234-58-285 58-285 156-234 234-156 285-58q286 0 491 192l-199 191q-117-113-292-113-123 0-227.5 62t-165.5 168.5-61 232.5 61 232.5 165.5 168.5 227.5 62q83 0 152.5-23t114.5-57.5 78.5-78.5 49-83 21.5-74h-416v-252h692q12 63 12 122zm867-122v210h-209v209h-210v-209h-209v-210h209v-209h210v209h209z"/></svg></div>
    <div class="mail" title="Share this through Email" onclick="window.open('mailto:?&body=https://mareknarozniak.com/2020/04/22/vertex-cover-independent-set-game-level-design/');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1792 710v794q0 66-47 113t-113 47h-1472q-66 0-113-47t-47-113v-794q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 100-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38-42.5-30.5q-91-64-262-182.5t-205-142.5q-62-42-117-115.5t-55-136.5q0-78 41.5-130t118.5-52h1472q65 0 112.5 47t47.5 113z"/></svg></div>
</div>

  </header>
  <div class="post-content" itemprop="articleBody">
    <p>I wanted to write something fun related to optimization since the moment of my graduation. In this article I will introduce you to few basic concepts in the graph theory, the <em>vertex cover</em> and <em>independent set</em>. By showing you how those can form <em>decision problems</em> and <em>optimization problems</em>, we will discover how useful they could be in modelling and solving practical problems in game level design. As an example, we will introduce a problem of placing Pokémon Centers and Pokémon Gyms on the map of Kanto region from the classic Pokémon games!</p>

<div class="thingy-centered">
<iframe src="https://giphy.com/embed/1g3BdDw8lf5VZTmbHi" width="480" height="442" frameborder="0" class="giphy-embed" allowfullscreen=""></iframe><p><a href="https://giphy.com/gifs/pokemon-1g3BdDw8lf5VZTmbHi">via GIPHY</a></p>
</div>

<p>I always loved to play Pokémon games, I do it until this day. The Pokémon-related optimization problem is mostly meant to entertain you a little bit while trying to learn some optimization, however it could (and I hope it will!) inspire you to try to use such optimization techniques for various design problems, such as in case of this article it is a game map design problem. This connects the optimization to the <em>procedural content generation</em>, often used in game design. After reading this article you can think of some other design problems which could be modelled as graphs.</p>

<p>Let us begin with the definitions. A <em>vertex cover</em> is a subset of vertices of a graph such that every edge of that graph has at least one of its endpoints included in the <em>vertex cover</em></p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msub><mi>V</mi><mtext>cover</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo><mo>∈</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo><mo>∩</mo><msub><mi>V</mi><mtext>cover</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mi mathvariant="normal">∅</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(VC)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">V_\text{cover}(G) \subseteq V(G), \forall \{a, b\} \in E(G), \{a, b\} \cap V_\text{cover}(G) \neq \emptyset \tag{VC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">cover</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">cover</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">V</span><span class="mord">C</span></span><span class="mord">)</span></span></span></span></span></span>

<p>As a <em>decision problem</em>, the <em>vertex cover problem</em> accepts a graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> and a positive integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> and determines if there exists a <em>vertex cover</em> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> of size <strong>at most</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, which is the NP-Complete problem formulated in <a class="citation" href="#Kar72">(Karp, 1972)</a>. As an <em>optimization problem</em>, the <em>the minimum vertex cover problem</em>, given a graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> finds the smallest possible value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> such that a <em>vertex cover</em> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> exists.</p>

<p>An <em>independent set</em> is a subset of vertices of a graph such that no two of such vertices are connected with an edge.</p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msub><mi>V</mi><mtext>indep</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo><mo>⊆</mo><msub><mi>V</mi><mtext>indep</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo><mo mathvariant="normal">∉</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(IS)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">V_\text{indep}(G) \subseteq V(G), \forall \{a, b\} \subseteq V_\text{indep}(G), \{a, b\} \notin E(G) \tag{IS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">indep</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">indep</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">I</span><span class="mord">S</span></span><span class="mord">)</span></span></span></span></span></span>

<p>In a way similar to the <em>vertex cover problem</em>, a NP-Complete <em>decision problem</em> called <em>independent set problem</em> can be formulated, accepting a graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> and a positive integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> and finding if an <em>independent set</em> of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> exists for the graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>, and as you might expect, an <em>optimization problem</em> called <em>maximum independent set</em> can be formulated which finds the <strong>largest</strong> possible value of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> for a given graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>.</p>

<p>Both <em>vertex cover</em> and <em>independent set</em> compliment each other, meaning that if we find one of them, we automatically have another for free!</p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msub><mi>V</mi><mtext>indep</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>∪</mo><msub><mi>V</mi><mtext>cover</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(VCIS)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">V_\text{indep}(G) \cup V_\text{cover}(G) = V(G) \tag{VCIS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">indep</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">cover</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span><span class="tag"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">V</span><span class="mord">C</span><span class="mord">I</span><span class="mord">S</span></span><span class="mord">)</span></span></span></span></span></span>

<p>Of course, for each <em>vertex cover</em> there exists a unique <em>independent set</em> and vice-versa, its not as any random two <em>vertex cover</em> and <em>independent set</em> could complete each other. What follows from that is the <em>minimum vertex cover</em> complements the <em>maximum independent set</em>. It makes sense, a most trivial <em>vertex cover</em> is a set of all the vertices <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span> and it corresponds to the most trivial <em>independent set</em> being an empty set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span>.</p>

<p>It is too little to be called a proper proof, but rather a formal argument. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo><mo>∈</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{a, b\} \in E(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span> be an edge from the graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> and let us keep in mind the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>VCIS</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{VCIS})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">VCIS</span></span><span class="mclose">)</span></span></span></span>, we find the following.</p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo><mo>∩</mo><msub><mi>V</mi><mtext>cover</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo><mo>⊆</mo><msub><mi>V</mi><mtext>indep</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{a, b\} \cap V_\text{cover}(G) = \emptyset \iff \{a, b\} \subseteq V_\text{indep}(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">cover</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">indep</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span></span>

<p>What I mean by that is violation of <em>vertex cover</em> implies the violation of <em>independent set</em> and vice-versa, because an edge that is not covered by one of its connected vertices, which violates <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>VC</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{VC})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">VC</span></span><span class="mclose">)</span></span></span></span>, in the compliment set corresponds to both vertices of the same edge being selected, which is exactly the violation of the definition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>IS</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{IS})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">IS</span></span><span class="mclose">)</span></span></span></span>.</p>

<p>Mathematically speaking, those two problems are closely related. Somehow still, I feel biased towards the <em>maximum independent set</em>, it somehow feels more natural to me to reason using the <em>independent sets</em>. What about you? Do you have any preferences? Feel free to let me know on Twitter!</p>

<p>Now, let us have a look at how those two problems could be used to model some game design problems, in this case, finding locations for Pokémon Centers and Pokémon Gyms in the Kanto region. Those of you who played Pokémon games know that Pokémon Centers are located pretty much everywhere, but for the purpose of this problem, let us imagine that it is long time in the past of the Pokémon history and in those times Kanto region was poor and could not afford to build a Pokémon Center in every town. Our optimization problem states as follows.</p>

<blockquote>
  <p>The poor region of Kanto cannot afford to place a Pokémon Center in every town, overall number of Pokémon Centers in the whole region has to be minimized but we need every route to be connected to at least one location with Pokémon Center to help trainers cure their Pokémons during their travels. To make the game harder, the Pokémon Gyms must not be placed at the town that contains a Pokémon Center, also no two Pokémon Gyms can be connected by a direct route.</p>
</blockquote>

<p>This problem maps directly onto <em>minimum vertex cover</em> problem, in which the Kanto region map becomes graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>, set of all towns is a set of all vertices <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span>, all the routes connecting the towns become edges <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span> and set of towns with Pokémon Center are represented by the <em>minimum vertex cover</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mtext>cover</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_\text{cover}(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">cover</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span> of the graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>, and set of towns with Pokémon Gyms are represented by the <em>maximum independent set</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mtext>indep</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_\text{indep}(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">indep</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>.</p>

<p>In order to have the Kanto region map be representable as graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>, we had to include a Special Region to prevent having routes connecting to each other without having a location at the intersection.</p>

<figure>
   <a href="#">
     <div class="fig-container">
     <img src="/assets/figures/vc_mis_kanto.png" class="figure" alt="Minimum Vertex Covers of Pokemon Kanto map" style="min-width: 50%" />
      </div>
   </a>
   <div class="caption"></div>
</figure>

<p>We are going to base our implementation on Python’s <code class="highlighter-rouge">frozenset</code>’s as it makes it hashable to embed sets within sets. Let’s make an alias for <code class="highlighter-rouge">frozenset</code>, from now on it will be <code class="highlighter-rouge">f</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="nb">frozenset</span>
</code></pre></div></div>

<p>A simple graph of three vertices, all connected could be build as follows.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">V</span> <span class="o">=</span> <span class="n">f</span><span class="p">({</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">})</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">f</span><span class="p">({</span><span class="n">f</span><span class="p">({</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">}),</span> <span class="n">f</span><span class="p">({</span><span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">}),</span> <span class="n">f</span><span class="p">({</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">})})</span>
<span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
</code></pre></div></div>

<p>We will build a recursive brute-force tool to explore all possible solutions and search for all <em>minimum vertex cover</em>. Such function is non-deterministic, needs to check all possibilities, for this check we can write a function which applies definition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>VC</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{VC})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">VC</span></span><span class="mclose">)</span></span></span></span> directly.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isVC</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
    <span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">G</span>
    <span class="n">cover</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cover</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>The recursive brute-force function will explore all the execution trees bounded by distance from root to leaves being at most as long as number of vertices of input graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>. This search function keeps track of size if currently explored solution (as we search for <em>minimum</em>) and will take take into such consideration only those partial solutions which are <em>vertex covers</em> tested using <code class="highlighter-rouge">isVC(sol, G)</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solveAll</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">minT</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isVC</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">sol</span><span class="p">]</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
        <span class="c1"># try to include the next element and see what happens...
</span>        <span class="n">lstL</span><span class="p">,</span> <span class="n">minL</span> <span class="o">=</span> <span class="n">solveAll</span><span class="p">(</span><span class="n">sol</span> <span class="o">+</span> <span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="n">idx</span><span class="p">]],</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
        <span class="c1"># try to skip the next element and see what happens...
</span>        <span class="n">lstR</span><span class="p">,</span> <span class="n">minR</span> <span class="o">=</span> <span class="n">solveAll</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
        <span class="c1"># whatever turned out to be better...
</span>        <span class="k">if</span> <span class="n">minL</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
            <span class="n">lst</span><span class="p">,</span> <span class="nb">min</span> <span class="o">=</span> <span class="n">lstL</span><span class="p">,</span> <span class="n">minL</span>
        <span class="k">elif</span> <span class="n">minL</span> <span class="o">==</span> <span class="nb">min</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">+=</span> <span class="n">lstL</span>
        <span class="k">if</span> <span class="n">minR</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
            <span class="n">lst</span><span class="p">,</span> <span class="nb">min</span> <span class="o">=</span> <span class="n">lstR</span><span class="p">,</span> <span class="n">minR</span>
        <span class="k">elif</span> <span class="n">minR</span> <span class="o">==</span> <span class="nb">min</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">+=</span> <span class="n">lstR</span>
    <span class="k">return</span> <span class="n">lst</span><span class="p">,</span> <span class="nb">min</span>
</code></pre></div></div>

<p>This function does not have an impressive computational complexity as it solves the problem in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy="false">∣</mo><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">∣</mo></mrow><annotation encoding="application/x-tex">N = \lvert V(G) \rvert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mclose">∣</span></span></span></span> but for the purpose of this article is to show how those problems can be used for modelling, not how to efficiently solve them. For this perhaps you could check the <a href="https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.approximation.vertex_cover.min_weighted_vertex_cover.html">networkx library</a> to get approximate solutions for large graphs really fast.</p>

<p>At this stage we can define the Kanto map in form of a graph. If you look at the map as it was introduced in the game you will see it is not a graph as there is an intersection of routes, which in graph paradigm would imply existence of edges connecting without a vertex. As we already mentioned earlier, to solve it we included a special region marked using red colour in the above figure.</p>

<p>Vertices of the graph are the towns, the in-game locations in general, along with the special region.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">V</span> <span class="o">=</span> <span class="n">f</span><span class="p">({</span>
    <span class="s">'Indigo Plateau'</span><span class="p">,</span>
    <span class="s">'Pallet Town'</span><span class="p">,</span>
    <span class="s">'Viridian City'</span><span class="p">,</span>
    <span class="s">'Pewter City'</span><span class="p">,</span>
    <span class="s">'Cinnabar Island'</span><span class="p">,</span>
    <span class="s">'Cerulean City'</span><span class="p">,</span>
    <span class="s">'Saffron City'</span><span class="p">,</span>
    <span class="s">'Celadon City'</span><span class="p">,</span>
    <span class="s">'Lavender Town'</span><span class="p">,</span>
    <span class="s">'Vermillion City'</span><span class="p">,</span>
    <span class="s">'Fuschia City'</span><span class="p">,</span>
    <span class="s">'Special Region'</span><span class="p">})</span>
</code></pre></div></div>

<p>Edges of the graph are all the routes, we do not need to name them explicitly, instead, it is sufficient to indicate which locations are connected.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">E</span> <span class="o">=</span> <span class="n">f</span><span class="p">({</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Indigo Plateau'</span><span class="p">,</span> <span class="s">'Viridian City'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Pallet Town'</span><span class="p">,</span> <span class="s">'Viridian City'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Viridian City'</span><span class="p">,</span> <span class="s">'Pewter City'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Pewter City'</span><span class="p">,</span> <span class="s">'Cerulean City'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Cerulean City'</span><span class="p">,</span> <span class="s">'Saffron City'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Saffron City'</span><span class="p">,</span> <span class="s">'Celadon City'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Celadon City'</span><span class="p">,</span> <span class="s">'Fuschia City'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Fuschia City'</span><span class="p">,</span> <span class="s">'Special Region'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Fuschia City'</span><span class="p">,</span> <span class="s">'Cinnabar Island'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Vermillion City'</span><span class="p">,</span> <span class="s">'Special Region'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Cinnabar Island'</span><span class="p">,</span> <span class="s">'Pallet Town'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Saffron City'</span><span class="p">,</span> <span class="s">'Lavender Town'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Lavender Town'</span><span class="p">,</span> <span class="s">'Cerulean City'</span><span class="p">}),</span>
    <span class="n">f</span><span class="p">({</span><span class="s">'Lavender Town'</span><span class="p">,</span> <span class="s">'Special Region'</span><span class="p">})</span>
    <span class="p">})</span>
</code></pre></div></div>

<p>We have everything we need to assemble the vertices and edges into graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> and apply the solver on it to find the <em>minimum vertex covers</em> via brute-force enumeration. The <code class="highlighter-rouge">minT</code> parameter has to be initiated with a big number (strictly larger than number of vertices) to make sure our solver does not neglect candidate solutions.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>G = (V, E)
lst, min = solveAll([], 0, 9999, list(V), G)
</code></pre></div></div>

<p>In the output, <code class="highlighter-rouge">lst</code> contains the optimal solutions and <code class="highlighter-rouge">min</code> is the size of the <em>minimum vertex cover</em>. For the Kanto map problem as we defined it, four solutions exist, they are all of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">∣</mo><msub><mi>V</mi><mtext>cover</mtext></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">∣</mo><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">\lvert V_\text{cover}(G) \rvert = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">cover</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mclose">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span></p>

<figure>
   <a href="#">
     <div class="fig-container">
     <img src="/assets/figures/vc_mis_results.png" class="figure" alt="Minimum Vertex Covers of Pokemon Kanto map" style="min-width: 80%" />
      </div>
   </a>
   <div class="caption"></div>
</figure>

<p>Each solution is a set of locations where Pokémon Center is to be built, it is a <em>vertex cover</em>, if you visually examine the above figure, you will see every route has connects at least one Pokémon Center. From definitions of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>VC</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{VC})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">VC</span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>IS</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{IS})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">IS</span></span><span class="mclose">)</span></span></span></span>, it is allowed to have two Pokémon Centers next to each other, but it is not allowed to have two gyms connected, and indeed our solver found only solutions that satisfy this criteria.</p>

<p>Intuitively, in this model, the smaller the <em>vertex cover</em> the larger the <em>independent set</em>, the fewer Pokémon Center, the more Pokémon Gyms. You could <em>relax</em> the requirement of finding <em>minimum vertex cover</em> to make the game easier, providing more Pokémon Center and fewer Gyms.</p>

<p>This is just a particular example, but in your own model for your own game, you would split the vertices of your graph (game map or game level) into two categories, first being something that helps the player (Pokémon Centers are healing Pokémon), could be healing potions, save game check points etc. The other category would be anything that makes the game harder, such as enemies, bosses, traps, obstacles etc. Then based on the effect you want to achieve, you would assing one of category to <em>vertex cover</em>, the other one to <em>independent set</em> and then using the graph optimization techniques you could generate game levels with predictable difficulty. You could include the solver in your game engine as a sort of <em>procedural content generation</em> engine and generate random levels of increasing difficulty as players get more experienced.</p>

<p>There are couple of other interesting things to think about after reading this article. Regarding the solving strategy, you probably tried to solve the instance of our problem mentally by looking at it. What was your strategy? Was it anything better than just trying different covers until one could works?</p>

<p>Other than that. Our <code class="highlighter-rouge">solveAll</code> function is naive and not very elaborate, how would you improve it? Is there a straightforward way to modify it to list all the possible <em>minimum vertex covers</em>? I will leave you there and if you have any comments, spot some errors or just want to discuss feel free to Tweet me!</p>

<ol class="bibliography"><li><span id="Kar72">Karp, R. (1972). Reducibility among combinatorial problems. In R. Miller &amp; J. Thatcher (Eds.), <i>Complexity of Computer Computations</i> (pp. 85–103). Plenum Press.</span></li></ol>


    <p>[<a href="#top">Back to Top</a>]</p>
  </div>
  

</article>

    </div>
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-93578712-1', 'auto');
  ga('send', 'pageview');
</script>


  </body>
</html>
