---
layout: post
title: Schnorr Signature
tags: [Cryptography, Python, Signatures, ECC]
description: Visual tutorial on performing Schnorr multi-signatures
image: /assets/figures/png/schnorr-signatures/multisignature_verification.png
lang: en_US
lang-ref: schnorr-signatures
katex: true
gist: https://gist.github.com/marekyggdrasil/203e4356a21f1244c1381e264032f583
---

It is not the first time digital signatures appear on this blog as we have already introduced the [ECDSA signatures](/2021/03/16/ecdsa/) earlier as well as a more general introduction to the elliptic curve cryptography has been provided in the [Diffie-Hellman key exchange over eliptic curve](/2020/11/30/ecdh/) tutorial.

To be honest, I was planning to write about something completely different but it was so heavily reliant on the Schnorr signature which is at the same time sufficiently different from ECDSA to deserve its own blog post. The concept I was going to write about will remain a surprise at the moment. If you read it in the future you might want to check what happened next and find it immediately.

As you might have already seen in the [ECDSA signatures](/2021/03/16/ecdsa/) tutorial, the digital signature permits to prove a message has been seen by a person owning a particular private-public key pair. The example we provided in that particular tutorial consisted of a mysterious messages from a from a friend and digital signature helped estimate which of the messages is more likely to be true.

In this tutorial we will do something similar, we will use different kind of signature and we will produce a multi-signature, which is a signature produced by multiple individuals. The Schnorr signatures {% cite Schnorr --file references %} have been known before ECDSA signatures, yet they were not so widely used due to the patent which expired in the year 2008. One of the advantages is existence of a proof that breaking the Schnorr signature is equivalent of breaking the discrete logarithm problem. Another one is the linear nature of the signature making it possible to easily combine multiple signatures together.

Let us break the convention and denote private key as $$ d $$, generator point we can keep as $$ G $$. Public key is thus

$$
\begin{aligned}
P = d G
\end{aligned}
$$

and additionally we find a random integer $$ k $$ which must fit within the prime order of the group generated by $$ G $$ and we produce a point on the curve as follows

$$
\begin{aligned}
R = k G
\end{aligned}
$$

then we calculate

$$
\begin{aligned}
s = k - H(m \vert\vert P) d
\end{aligned}
$$

where $$ m $$ is the signed message and $$ \vert\vert $$ denotes concatenation and $$ H() $$ is the hash function as those explained in our [hashing functions](/2020/12/29/hash/) tutorial. The signature is a tuple

$$
\begin{aligned}
\left< s, R \right> \tag{I}
\end{aligned}
$$

To verify the signature we proceed as follows. Given $$ \left< s, R \right> $$ and message $$ m $$ we have to check if

$$
\begin{aligned}
s G = R + H(m \vert\vert P) P
\end{aligned}
$$

We will be using the [minicurve library](https://github.com/marekyggdrasil/minicurve) for implementing and visualizing this signature.

```python
from minicurve import MiniCurve as mc
from minicurve.helpers import inverse
```

The signature method is

```python
def sign(m, k, d, G, p):
    # calculate public key R = k*G
    R = k*G
    # calculate e = H(M || r) where || is concatenation
    e = hashtard(m, p)
    # calculate the signature
    s = np.mod(k + d*e, p)
    # signature is s, R
    return s, R
```

where $$ k $$ is the random nonce, $$ p $$ is the order of the entire finite field. We also the verification method

```python
def verify(m, s, G, P, R, p):
    # e_v = H(M || r_v)
    e = hashtard(m, p)
    # calculate the verification
    lhs = s*G
    rhs = R+e*P
    # test if lhs = rhs
    if lhs == rhs:
        return True, lhs, rhs
    return False, lhs, rhs
```

The implementation is confusing, please refer to previous ECC tutorials for more details.

Now to produce multi-signature we start by combining the keys of each of the participants using curve point addition

$$
\begin{aligned}
P_c = P_A + P_B
\end{aligned}
$$

then each of the participant is producing the signature, this should give us $$ \left< s_A, R_A \right> $$ and $$ \left< s_B, R_B \right> $$ for Bob. The $$ s_A $$ and $$ s_B $$ can be combined using modulo integer addition and for random points we use eliptic curve addition

$$
\begin{aligned}
s_c &= s_A + s_B \mod p \\
R_c &= R_A + R_B
\end{aligned}
$$

which gives as a multi-signature $$ \left< s_c, R_c \right> $$. This signature is verifiable only for the composite key $$ P_c $$, for the individual keys of Alice and Bob it is not valid.

As usual let us perform a little demo. Lets imagine a scenario in which a very important message needs to be signed by both Alice and Bob. Message goes as follows

```
I say we take off and nuke the entire site from orbit. It's the only way to be sure.
```

Private keys of Alice and Bob are respectively $$ 3 $$ and $$ 5 $$. Very insecure and small numbers, as they must fit in the range of prime order of group resulting from the generating point. Keys can be visualized as follows.

{% include figure.html min-width="100%" url="#" fll="/assets/figures/png/schnorr-signatures/multisignature_keys.png" alt="" %}

then their respective random nonces are $$ 3 $$ and $$ 5 $$. Along with the ready signatures and both sides of verification equation

{% include figure.html min-width="100%" url="#" fll="/assets/figures/png/schnorr-signatures/multisignature_verification.png" alt="" %}

and we can observe that for all cases left hand side equals the right hand side indicating signatures validity.

If you run the [source code](https://gist.github.com/marekyggdrasil/203e4356a21f1244c1381e264032f583) of this example you will see the outputs confirming validity of the result

```
Trying to verify signature with just Alice's public key
failed
Trying to verify signature with just Bob's public key
failed
Trying to verify signature with composite public key
valid
```

This was short tutorial, but I hope it will end up useful as once we have Schnorr signatures and multi-signatures we can go into more advanced concepts, such as Pedersen commitments, confidential transactions, adaptor signatures and much much more!

If you like to know more, I based this tutorial on [what the heck is Schnorr](https://medium.com/bitbees/what-the-heck-is-schnorr-52ef5dba289f) medium article and [cryptography fandom Schnorr signature page](https://cryptography.fandom.com/wiki/Schnorr_signature).

I would like to thank [John Tromp](http://tromp.github.io/) for answering my questions and providing comments regarding Schnorr signatures on the cryptography channel in the [grincoin keybase team](https://keybase.io/team/grincoin). I also thank [vegycslol](https://forum.grin.mw/u/vegycslol/summary) for a discussion that helped improve the quality of this tutorial and make it lot less confusing.

If you find typos or errors in this text please do not hesitate to let me know, for which best way is to simply tweet me.

{% bibliography --file references --file wiki --cited %}
